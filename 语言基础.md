大数据架构底层核心技能⭐️⭐️⭐️⭐️

JAVA：Java高级(虚拟机JVM、多线程&高并发、网络通信IO）

PYTHON

SCALA

SQL以及基本调优，主要是Hive SQL



HiveSQL： https://www.bilibili.com/video/BV1og4y1w7W3/?p=108&share_source=copy_web&vd_source=b0c3cad8671d1f2fa75d01a0a18e195c



# JAVA 



## JDK JRE JVM

Java程序是运行在JVM([Java虚拟机](https://so.csdn.net/so/search?q=Java虚拟机&spm=1001.2101.3001.7020))上的，在开发程序之前要配置Java开发环境，而配置环境要做的就是JDK的安装和配置。

三者的大致结构是这样的，简单来说就是JDK包含JRE,JRE又包含JVM的关系。如下图所示：

<img src="assets/image-20230818184432597.png" alt="image-20230818184432597" style="zoom:50%;" />

- JDK：Java Development Kit 是Java的标准开发工具包，普通用户只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。
- JRE：Java runtime environment 是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。
- JVM：Java Virtual Machine 是Java的虚拟机，是JRE的一部分（JVM=JRE的bin）。它是**整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机**。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。





## JAVA的类、接口、泛型

类用于描述具体的对象和实现具体的功能，而接口用于定义规范和行为契约，以便实现类来实现和提供具体的功能。

类提供了更具体和具有实现细节的功能，而接口更加抽象和灵活，可以用于实现多个类之间的共享行为。

泛型的好处是在编译的时候**检查类型安全**，并且所有的强制转换都是自动和隐式的， 以提高代码的重用率。 

- 不加`<String>`指定List的存放数据的类型，会无法加入字符串元素，因为默认只能加`Object`对象，只能接收父类，不能接收子类对象

  ```java
  // 编译时报warning 但可以运行
  public class HelloWorld {
      public static void main(String[] args) {
  		java.util.ArrayList list = new java.util.ArrayList();
  		list.add("Java Programming"); 
  		list.add(123);  
  		list.add(true); 
  		for (Object o : list){
  			System.out.println(o);
  		}
  	}
  }
  // 指定泛型 编译也没问题 但没法再加其他类型的元素
  public class test {
      public static class ShowUncheckedWarning {
          public static void main(String[] args) {  
              java.util.ArrayList<String> list = new java.util.ArrayList<String>();
              list.add("Java Programming");
          }
      }
  }
  ```

- 泛型类：使用引入类型作为类的全局对象

  ```java
  public class Person<T> {
      private T t;
  
      public Person(T t) {
          this.t = t;
      }
  
      public String toString() {
          return "参数的类型是：" + t.getClass().getCanonicalName();
      }
  }
  
  package Generic;
  
  // 继承父类的泛型 子类就可以与父类一起共享类型参数
  public class Teacher<T, S> extends Person<T> {
      protected T t;
      private S s;
  
      public Teacher(T t) {
          super(t);
      }
  
      public void set(T t, S s) {
          this.t = t;
          this.s = s;
      }
  }
  ```

- 泛型接口：其实和泛型类功能上差不多，以下是一个具体的例子

  ```java
  public interface Factory<T> {
      public T create();
  }
  public class Car {
  }
  public class Computer {
  }
  
  public class CarFacotry implements Factory<Car> {
      @Override
      public Car create() {
          System.out.println("装载发动机！");
          System.out.println("装载座椅！");
          System.out.println("装载轮子！");
          return new Car();
      }
  }
  public class ComputerFactory implements Factory<Computer> {
      @Override
      public Computer create() {
          System.out.println("装载主板！");
          System.out.println("装载CPU!");
          System.out.println("装载内存");
          return new Computer();
      }
  }
  ```

  

- 泛型方法：为方法声明一个类型参数，通过`.newInstance()`反射方法，创建返回实例

  ```java
  import java.util.Date;
  
  public class Factory {
      //    定义泛型方法
      public <T> T generator(Class<T> t) throws Exception {
          return t.newInstance();
      }
  
      //  使用泛型方法
      public static void main(String[] args) throws Exception {
          Date date = new Factory().generator(Date.class);
          System.out.println(date);
      }
  }
  ```

  泛型确保了类型的准确性 ，可以使用该方法生成任何继承自Object类的实例。 然前提是该类有无参构造方法。

- 反射机制

  - 优点
    - 增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作
    - 提高代码的复用率,比如动态代理,就是用到了反射来实现
    - 可以在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行动态调用
  - 缺点
    - 反射会涉及到动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低。
    - 使用反射以后,代码的可读性会下降
    - 反射可以绕过一些限制访问的属性或者方法，可能会导致破坏了代码本身的抽象性和安全性



## JAVA数组排序

https://blog.csdn.net/m0_59408612/article/details/131824320

https://blog.csdn.net/qq_41030039/article/details/100176410/

`Arrays.sort(数组arr, int formIndex（起始位置）, int toIndex（终止位置)`

使用`Collections.reverseOrder()`参数进行降序时，数组不能是基本数据类型（String不是基本数据类型）

<img src="assets/image-20230908223248713.png" alt="image-20230908223248713" style="zoom:50%;" />

```java
// int类型的一维数组 降序时需要装箱为Integer的包装类
Integer[] boxedArray = Arrays.stream(arr).boxed().toArray(Integer[]::new);
Arrays.sort(boxedArray, Collections.reverseOrder());
```

## 重载排序

`a`也不能是基本数据类型，需要时一个类

```java
Arrays.sort(a, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;
    }
});
// 降序
Arrays.sort(a, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;
    }
});
```

lambda表达式

```java
Arrayssort(intarr, (Integer a, Integer b)->{return a-b;});
Arrays.sort(strs, (String first, String second) ->
{
    if(first.length() < second.length()) return -1;
    else if(first.length() > second.length()) return 1;
    else return 0;
});
```

如果排序比较器太长，单独写成一个类，再声明对象传入给sort()

1. **内部比较器：** 需要比较的对象必须实现Comparable接口，并重写compareTo(T o)方法，表明该对象可以用来排序，**否则不能直接使用**Arrays.sort()方法。

   ```java
   public class Employee implements Comparable<Employee> { 
           // 比较此对象与指定对象的顺序  
       
       // get set 成员属性
       
       @Override  
       public int compareTo(Employee o) {  
           // 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  
           int result = this.id > o.id ? 1 : (this.id == o.id ? 0 : -1);  
           // 如果编号相等，则比较薪资  
           if (result == 0) {  
               // 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  
               result = this.salary > o.salary ? 1 : (this.salary == o.salary ? 0 : -1); 
           }  
           return result;  
       }   
   }
   ```

   ```java
   	public static void main(String[] args) {  
           List<Employee> employees = new ArrayList<Employee>();  
           employees.add(new Employee(2, 5000));  
           employees.add(new Employee(1, 4500));  
           employees.add(new Employee(4, 3500));  
           employees.add(new Employee(5, 3000));  
           employees.add(new Employee(4, 4000));  
           // 内部比较器：要排序的对象要求实现了Comparable接口 ,直接传入该对象即可
           Arrays.sort(employees);  
           System.out.println("通过内部比较器实现：");  
           System.out.println(employees);  
   	}
   ```

2. **外部比较器**： 需要自己写一个比较器实现Comparator接口，并实现compare(T o1, T o2)方法，根据自己的需求定义比较规则。**使用外部比较器这种方式比较灵活**，例如现在需求是按照员工编号和薪资进行排序，以后可能按照姓名进行排序，这时只要再写一个按照姓名规则比较的比较器就可以了。

   ```java
   class EmployeeComparable implements Comparator<Employee> {  
       // 不需要对象预选有比较方法，要用到再定义比较器
       @Override  
       public int compare(Employee o1, Employee o2) {  
           // 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  
           int result = o1.getId() > o2.getId() ? 1 : (o1.getId() == o2.getId() ? 0 : -1);  
           // 如果编号相等，则比较薪资  
           if (result == 0) {  
               // 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  
               result = o1.getSalary() > o2.getSalary() ? 1 : (o1.getSalary() == o2.getSalary() ? 0 : -1);  
           }  
           return result;  
       }  
   } 
   public class TestEmployeeCompare {  
   	public static void main(String[] args) {  
           List<Employee> employees2 = new ArrayList<Employee>();  
           employees2.add(new Employee(2, 5000));  
           employees2.add(new Employee(1, 4500));  
           employees2.add(new Employee(4, 3500));  
           employees2.add(new Employee(5, 3000));  
           employees2.add(new Employee(4, 4000));  
           // 外部比较器：自定义类实现Comparator接口  ，需要传入自定义比较器类
           Arrays.sort(employees2, new EmployeeComparable());  
           System.out.println("通过外部比较器实现：");  
           System.out.println(employees2);  
       }  
   }
   ```

   

## 字符串正则

- 匹配字符串中的**数字**：`\d`
  示例：`String regex = "\\d";`
- 匹配字符串中的**字母**：`\p{Alpha}`
  示例：`String regex = "\\p{Alpha}";`
- 匹配字符串中的**空格**：`\s`
  示例：`String regex = "\\s";`
- 匹配字符串中的**单词**：`\w`
  示例：`String regex = "\\w";`
- 匹配字符串中的**非单词字符**：`\W`
  示例：`String regex = "\\W";`
- 匹配字符串中的**任意字符**：`.`
  示例：`String regex = ".";`
- 匹配字符串中的**重复字符**：`+`
  示例：`String regex = "a+";`
- 匹配字符串中的**特定字符集合**：`[]`
  示例：`String regex = "[abc]";`
- 匹配字符串中的**数字范围**：`[0-9]`
  示例：`String regex = "[0-9]";`

使用`.matches`方法和`Pattern`类

```java
import java.util.regex.*;

public class Main {
    public static void main(String[] args) {
        String input = "Hello, World!";

        // 使用 matches() 方法进行匹配
        boolean isMatch = input.matches("Hello.*");
        System.out.println("匹配结果: " + isMatch); // true

        // 使用 Pattern 和 Matcher 进行匹配
        Pattern pattern = Pattern.compile("World");
        Matcher matcher = pattern.matcher(input);
        boolean isFound = matcher.find(); // true
        System.out.println("查找结果: " + isFound);
    }
}
```



# SQL

1. 观察查询结果，是要处理from什么表，需不需要join 或者 in作为预先结果
2. 加分组或判断，使得到该查询结果
3. 写输出



数据：学生表、老师表、课程表、分数表

```sql
hive>
-- 创建学生表
DROP TABLE IF EXISTS student_info;
create table if not exists student_info(
    stu_id string COMMENT '学生id',
    stu_name string COMMENT '学生姓名',
    birthday string COMMENT '出生日期',
    sex string COMMENT '性别'
) 
row format delimited fields terminated by ',' 
stored as textfile;

-- 创建课程表
DROP TABLE IF EXISTS course_info;
create table if not exists course_info(
    course_id string COMMENT '课程id',
    course_name string COMMENT '课程名',
    tea_id string COMMENT '任课老师id'
) 
row format delimited fields terminated by ',' 
stored as textfile;

-- 创建老师表
DROP TABLE IF EXISTS teacher_info;
create table if not exists teacher_info(
    tea_id string COMMENT '老师id',
    tea_name string COMMENT '老师姓名'
) 
row format delimited fields terminated by ',' 
stored as textfile;

-- 创建分数表
DROP TABLE IF EXISTS score_info;
create table if not exists score_info(
    stu_id string COMMENT '学生id',
    course_id string COMMENT '课程id',
    score int COMMENT '成绩'
) 
row format delimited fields terminated by ',' 
stored as textfile;
```

## 简单查询

1. `count()`返回记录数 

   姓李的老师数量，返回别名

   - 模糊匹配：名字里带“山”：`where name like "%山%"`

   ```sql
   select count(*) li_count
   from teacher_info
   where name like '李%';
   ```

   参加考试的学生数

   ```sql
   select count(distinct stu_id) stu_num
   from score_info;
   ```

2. 排序

   04编号课程不合格的分数信息，按分数降序输出

   ```sql
   select *
   from score_info
   where course_id='04' and score<60
   order by score desc;
   ```

3. 多表连接与子查询

   数学不合格的学生信息和其数学成绩，按学号升序排列

   - 使用子查询：先知道数学对应的id，再在分数表查到数学不合格的学生id和数学分数返回表，与学生表按照学生id join起来，返回学生信息和数学成绩

     ```sql
     select s.*, t1.score
     from student_info s join (
         select stu_id, score from score_info 
         where course_id=(
             select course_id from course_info where course_info.course_name='数学'
         ) and score<60) t1 
         on s.stu_id = t1.stu_id
     order by s.stu_id;  # 默认asc 升序
     ```

   - 直接使用多表连接，可读性强，查询效率高，但子查询可以通过过滤减少多表连接时记录数

     ```sql
     select s.*, t1.score
     from student_info s 
     join score_info t1 on s.stu_id = t1.stu_id
     join course_info t2 on t1.course_id = t2.course_id
     where t2.course_name='数学' and t1.score<60
     order by s.stu_id;
     ```

   查询课程编号03且课程成绩在80分以上的学生学号、姓名和课程信息

   ```sql
   select s1.stu_id, s2.stu_name, c.*
   from score_info s1
   join course_info c on s1.course_id=c.course_id
   join student_info s2 on s1.stu_id=s2.stu_id
   where s1.course_id='03' and s1.score>80;
   
   # 子查询 先从成绩表中查到满足条件的学生学号 再与课程表、学生表连接
   select s1.stu_id, s1.stu_name, c.*
   from student_info s1
   join (
   	select stu_id from score_info where course_id='03' and score>80
   ) t on s1.stu_id=t.stu_id
   join course_info c on s1.course_id=c.course_id
   ```

   查询课程不同成绩相同的记录，返回学生编号、课程编号、成绩

   ```sql
   select s1.stu_id, s1.course_id, s1.score
   from score_info s1
   join score_info s2 on s1.stu_id=s2.stu_id and 
   					  s1.course_id<>s2.course_id and 
   					  s1.score=s2.score;
   ```

   查询学过课程编号01和02的学生，返回学号、姓名

   ```sql
   select s2.stu_id as `学号`, s2.stu_name as `姓名`
   from score_info s1
   join student_info s2 on s1.stu_id=s2.stu_id
   where s1.course_id='01' and s1.stu_id in (
   	select stu_id from score_info where course_id='02'
   );
   
   # 优化 先用子查询 把满足条件的学生返回，再join连接
   select s2.stu_id as `学号`, s2.stu_name as `姓名`
   from (
   	select stu_id from score_info
       where course_id='01' and 
       	  stu_id in (select stu_id from score_info where course_id='02')
   ) s1 join student_info s2 on s1.stu_id=s2.stu_id;
   ```

   



## 分组汇总

1. 分组求和

   查询课程编号02的总成绩

   - ⭐️注意：出现了聚合函数，不能将普通列也和聚合结果一起查询，除非这个列存在group by操作之后
   - 如果要返回`course_id`，必须要加`group by course_id`
   - 否则可以不用`group by course_id`，直接返回一个常量值，但不通用

   ```sql
   select course_id, sum(score) score_sum
   from score_info
   where course_id='02'
   group by course_id;
   
   select 02 course_id, sum(score) score_sum
   from score_info
   where course_id='02';
   ```

2. 分组查询

   查询各科成绩的最高和最低分，返回课程号、最高分、最低分

   ```sql
   select courese_id, max(score) max_score, min(score) min_score
   from score_info
   group by course_id;
   ```

   查询每门课程有多少学生参加了考试

   ```sql
   select course_id, count(stu_id)
   from score_info
   group by course_id;
   ```

3. 分组结果的条件查询

   查询平均成绩大于60分的学生的学号和平均成绩

   - 使用having + 聚合函数可用于聚合函数之后的判断，不能使用where+聚合函数的判断，其执行目标是查询结果集之前，执行顺序在gropu by和聚合函数之前
   - 一般的执行顺序：**from-->where-->group by -->having + 聚合函数 --- >select --> order**

   ```sql
   select stu_id, avg(score) score_avg
   from score_info
   group by stu_id
   having score_avg > 60;
   ```

   查询至少考了四门课程的学生学号

   ```sql
   select stu_id, count(distinct course_id) course_cnt
   from score_info
   group by stu_id
   having course_cnt >= 4;
   ```

   查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列

   ```sql
   select course_id, avg(score) score_avg
   from score_info
   group by course_id
   order by score_avg asc, course_id desc; 
   ```

   查询一共参加了三门课程且其中一门为语文的学生id和姓名

   ```sql
   # 多表连接
   select stu.stu_id, stu.stu_name
   from score_info s 
   join course_info c on s.course_id=c.course_id
   join student_info stu on s.stu_id=stu.stu_id
   where c.course_name='语文'
   group by s.stu_id
   having count(distinct s.course_id) = 3;
   
   # 子查询  先查出选了语文并且参加了三门课程的学生id
   select stu_id, stu_name 
   from student_info 
   where stu_id in 
   (
       select stu_id
       from score_info where course_id = 
       	(select course_id from course_info where course_name='语文')
       group by stu_id
       having count(distinct course_id)=3)
   );
   ```

   查询没有学全所有课的学生学号、姓名

   - 学生表 **左连接** 分数表，防止遗漏没有参与任何考试的学生
   - 同上，保证group by 学生学号姓名，否则无法select

   ```sql
   select s1.stu_id, s1.stu_name
   from student_info s1
   left join score_info s2 on s1.stu_id=s2.stu_id
   group by s1.stu_id, s1.stu_name
   having count(distinct course_id) < (
   	select count(distinct course_id) from course_info
   );
   
   # 优化：课程总数的子查询只执行一次
   select s1.stu_id, s1.stu_name
     student_info s1
   left join score_info s2 on s1.stu_id = s2.stu_id
   join (
       select count(distinct course_id) total_courses from course_info
   ) t on 1=1
   group by s1.stu_id, s1.stu_name
   having count(distinct s2.course_id) < t.total_courses;
   ```

   查询所有学生的学号、姓名、选课数和总成绩

   - 用到总成绩 需要进行groupby 分组聚合

   ```sql
   select s1.stu_id, count(course_id) course_cnt, sum(score) score_sum
   from student_info s1
   left join score_info s2 on s1.stu_id=s2.stu_id
   group by s1.stu_id, s1.stu_name;
   ```

   查询学过“李体音”老师**所有课**的学生学号、姓名

   ```sql
   select s1.stu_id, s1.stu_name
   from score_info s1, 
   join (
       select course_id, count(*) cnt, 
       from course_info where teacher_id=(
       	select teacher_id from teacher_info where teacher_name='李体音')
       group by course_id
   ) c on c.course_id=s1.course_id
   join student_info s2 on s1.stu_id=s2.stu_id
   group by stu_id
   having count(distinct c.course_id)=cnt;
   
   # 上面不知道对不对， 下面先查询课程表中'李体音'老师教的课程数，再判断该值与成绩表中按学生分组汇总课程数，最后返回学生表信息
   select stu_id, stu_name
   from student_info where stu_id in (
   	select stu_id from score_info group by stu_id 
   	having count(stu_id) = (select count(*) from course_info 
                               where teacher_id=(
                                   select teacher_id from teacher_info 
                                   where teacher_name='李体音')
                              )
   );
   ```

   查询学过“李体音”老师**任意一门**课程的学生学号、姓名

   - 和上面的类似， in 可以和 表连接达到right join的效果

     >`JOIN` 内连接：是一般化的关联操作，仅返回满足连接条件的匹配行
     >
     >`LEFT JOIN` 左（外）连接：保留了左表的所有行，并返回与左表满足连接条件的右表匹配行。
     >
     >`RIGHT JOIN` 右（外）连接：保留了右表的所有行，并返回与右表满足连接条件的左表匹配行。

   ```sql
   select stu_id, stu_name
   from student_info where stu_id in ( # not in则表示没有学过李体音教的课的学生
   	select distinct stu_id from score_info  
   	where course_id in (select course_id 
           from course_info where teacher_id=(
               select teacher_id from teacher_info where teacher_name='李体音'))
       group by stu_id
   );
   
   # 使用表连接 取代 in 
   select t1.stu_id, si.stu_name
   from
   (
       select stu_id from score_info si where course_id in
       (
           select
              course_id
           from course_info c
           join teacher_info t
           on c.tea_id = t.tea_id
           where tea_name='李体音'
       )
       group by stu_id
   ) t1 join student_info si on t1.stu_id=si.stu_id;
   ```

   查询与学号为001的学生至少有一门课相同的学生学号、姓名

   ```sql
   select stu_id, stu_name
   from student_info
   where stu_id in (
   	select distinct stu_id from score_info
       where stu_id<>'001' and course_id in (
           	select course_id from score_info where stu_id='001'
           )
   )
   ```

   查询学生的平均成绩，依次返回一个学生的学生名、课程名、课程成绩和平均成绩

   ```sql
   select s1.name, c.name, s3.score, s2.score_avg
   from student_info s1
   join (
   	select stu_id, avg(score) score_avg
       from score_info 
       group by stu_id, 
   ) s2 on s1.stu_id=s2.stu_id
   join score_info s3 on s1.stu_id=s3.stu_id
   join course_info c on c.course_id=s3.course_id
   order by s2.score_avg desc;
   ```

## 窗口函数

- 语法：

  ```text
  <窗口函数> over (partition by <用于分组的列名>
                  order by <用于排序的列名>)
  ```

  因为窗口函数是对where或者group by子句处理后的结果进行操作，所以**窗口函数原则上只能写在select子句中**。

  partition子句可以省略，省略就是不指定分组，但是这一般会失去窗口函数的功能，一般不用

- 窗口函数举例：

  - 聚合函数，如sum(列名)，avg(列名)，count(列名)，max(列名), min(列名)等
  - 专用窗口函数，rank(列名), dense_rank(列名), row_number(列名)等

- 作用：

  - group by+聚合函数，无法对分组内部的数据进行非聚合的处理（分组内排序等），使用窗口函数解决

  - 不改变原始表的行数

    

1. 查询不同科目的学生成绩排名，返回学号、科目、成绩、排名

   - 按照科目分组，各科按照成绩排名，对应得到该成绩的学生学号

   ```sql
   select *, rank() over(partition by course_id
                         order by score desc) as ranking
   from score_info
   ```

   - rank, dense_rank, row_number的区别

     <img src="assets/image-20230919215713499.png" alt="image-20230919215713499" style="zoom:50%;" />

     - rank：有并列名次的行，会占用下一名次的位
     - dense_rank：有并列名次的行，不会占用下一名次的位
     - row_number：没有并列名次

2. 聚合函数+窗口函数：查询结果是逐行聚合的，相当于把聚合的中间过程返回给当前行

   ```sql
   select *,
      sum(成绩) over (order by 学号) as current_sum,
      avg(成绩) over (order by 学号) as current_avg,
      count(成绩) over (order by 学号) as current_count,
      max(成绩) over (order by 学号) as current_max,
      min(成绩) over (order by 学号) as current_min
   from 班级表
   
   ```

   <img src="assets/image-20230919220950068.png" alt="image-20230919220950068" style="zoom:50%;" />

   >感觉其实用处不大：聚合函数作为窗口函数，可以在每一行的数据里直观的看到，**截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。**

   



# Hive SQL

电商生产环境中的**用户信息表、商品信息表、商品分类表、订单信息表、订单明细表、登录明细表、商品价格变更明细表、配送信息表、好友关系表**

用户信息表结构

| user_id(用户id) | gender(性别) | birthday(生日) |
| --------------- | ------------ | -------------- |
| 101             | 男           | 1990-01-01     |
| 102             | 女           | 1991-02-01     |
| 103             | 女           | 1992-03-01     |
| 104             | 男           | 1993-04-01     |

商品信息表结构 sku_info

| sku_id(商品id) | name(商品名称) | category_id(分类id) | from_date(上架日期) | price(商品价格) |
| -------------- | -------------- | ------------------- | ------------------- | --------------- |
| 1              | xiaomi 10      | 1                   | 2020-01-01          | 2000            |
| 6              | 洗碗机         | 2                   | 2020-02-01          | 2000            |
| 9              | 自行车         | 3                   | 2020-01-01          | 1000            |

商品分类信息表结构 sku_detail

| category_id(分类id) | category_name(分类名称) |
| ------------------- | ----------------------- |
| 1                   | 数码                    |
| 2                   | 厨卫                    |
| 3                   | 户外                    |

订单信息表结构 order_info

| order_id(订单id) | user_id(用户id) | create_date(下单日期) | total_amount(订单金额) |
| ---------------- | --------------- | --------------------- | ---------------------- |
| 1                | 101             | 2021-09-30            | 29000.00               |
| 10               | 103             | 2020-10-02            | 28000.00               |

订单明细表结构 order_detail

| order_detail_id(订单明细id) | order_id(订单id) | sku_id(商品id) | create_date(下单日期) | price(商品单价) | sku_num(商品件数) |
| --------------------------- | ---------------- | -------------- | --------------------- | --------------- | ----------------- |
| 1                           | 1                | 1              | 2021-09-30            | 2000.00         | 2                 |
| 2                           | 1                | 3              | 2021-09-30            | 5000.00         | 5                 |
| 22                          | 10               | 4              | 2020-10-02            | 6000.00         | 1                 |
| 23                          | 10               | 5              | 2020-10-02            | 500.00          | 24                |
| 24                          | 10               | 6              | 2020-10-02            | 2000.00         | 5                 |

登录明细表结构 user_login

| user_id(用户id) | ip_address(ip地址) | login_ts(登录时间)  | logout_ts(登出时间) |
| --------------- | ------------------ | ------------------- | ------------------- |
| 101             | 180.149.130.161    | 2021-09-21 08:00:00 | 2021-09-27 08:30:00 |
| 102             | 120.245.11.2       | 2021-09-22 09:00:00 | 2021-09-27 09:30:00 |
| 103             | 27.184.97.3        | 2021-09-23 10:00:00 | 2021-09-27 10:30:00 |

商品价格变更明细表结构

| sku_id(商品id) | new_price(本次变更之后的价格) | change_date(变更日期) |
| -------------- | ----------------------------- | --------------------- |
| 1              | 1900.00                       | 2021-09-25            |
| 1              | 2000.00                       | 2021-09-26            |
| 2              | 80.00                         | 2021-09-29            |
| 2              | 10.00                         | 2021-09-30            |

配送信息表结构

| delivery_id（运单id） | order_id（订单id） | user_id（用户id） | order_date（下单日期） | custom_date（期望配送日期） |
| --------------------- | ------------------ | ----------------- | ---------------------- | --------------------------- |
| 1                     | 1                  | 101               | 2021-09-27             | 2021-09-29                  |
| 2                     | 2                  | 101               | 2021-09-28             | 2021-09-28                  |
| 3                     | 3                  | 101               | 2021-09-29             | 2021-09-30                  |

好友关系表结构

| user1_id（用户1 id） | user2_id（用户2 id） |
| -------------------- | -------------------- |
| 101                  | 1010                 |
| 101                  | 108                  |
| 101                  | 106                  |

收藏信息表结构

| user_id(用户id) | sku_id(商品id) | create_date(收藏日期) |
| --------------- | -------------- | --------------------- |
| 101             | 3              | 2021-09-23            |
| 101             | 12             | 2021-09-23            |
| 101             | 6              | 2021-09-25            |

## 初级函数

1. 日期函数

   - `year(string datestr)`函数：参数datestr是格式化日期字符串，返回值为日期所属年份，**int类型**。
   - `datediff(string enddate, string startdate)`函数：startdate和enddate均为yyyy-MM-dd格式的日期字符串，返回值为二者的天数差，**int类型**。如datediff('2022-03-01', '2022-02-21')返回值为8。
   - `date_format(date/timestamp/string dt, string formatstr)`：将date/timestamp/string类型的日期字段dt转换为formatstr格式的日期字符串，从而可以使用日期字符串进行聚合函数中的比较运算

   查询2021年总销量小于100的商品，不考虑上架1个月的商品，返回该商品名

   - 目标数据需要满足三个条件
   - 条件一：下单操作发生在2021年；条件二：2021年总销量小于100；条件三：上架时间不小于1个月

   ```hive
   select s.sku_name
   from order_detail o 
   join (
       select sku_id, name from sku_info where datediff(sku_from_date, '2023-08-19')>30
   ) s on o.sku_id=s.sku_id
   where year(o.create_date)=2023
   group by sku_id
   having sum(sku_id)<100
   ```

   查询日增用户，返回日期、用户增长数

   - 登录明细表中，返回用户的最早登录时间，则该日的增加用户+1，最后按照日期分组
   - 子查询出来一张表的信息够了，不需要表的连接

   ```hive
   select register_date, count(*) user_cnt
   from (
   	select user_id, min(date_format(login_ts, 'yyyy-MM-dd')) register_date
       from user_login	
       group by user_id
   )
   group by register_date
   ```

2. 数值转换函数

   - `if(boolean testCondition, T1 value1, T2 value2)`：判断testCondition是否为真，是则返回value1，否则返回value2，value1和value2类型可以不同，且后者可以为null
   - `nvl(T value, T default_value)`：value为null则返回default_value，否则返回value。
   - `CAST(<expression> AS DECIMAL(16, 2))`：
     - `CAST` 函数用于将一个表达式转换为指定的数据类型。
     - `DECIMAL(16, 2)` 表示总共 16 位数字，其中小数部分占据 2 位。

   ⭐️查询用户的注册日期、总登录数、2021年的登录数、订单数和订单总金额

   - count()函数+ if()函数，得到带条件的登录数
   - 用户登录left join用户下单，保证没有下过单的用户也有查到，再用nvl()函数处理成下单为0

   ```hive
   select t1.user_id, register_date, total_login, login_2021, 
   	nvl(order_cnt_2021, 0) order_cnt_2021, 
   	cast(nvl(total_money_2021, 0.0) as decimal(16, 2)) total_money_2021
   from (
   	-- 用户的注册日期、总登录数、2021年的登录数
   	select user_id, min(date_format(login_ts, 'yyyy-MM-dd')) register_date, count(1) total_login, count(if(year(login_ts)=2021, 1, null)) login_2021
       from user_login	
       group by user_id
   ) t1 left join 
   (
       -- 用户2021年的订单数和订单总金额
       select user_id, count(order_id) order_cnt_2021, sum(total_amount)) total_money_2021
       from order_info
       where year(create_date)=2021
       group by user_id
   ) t2 on t1.user_id=t2.user_id
   ```

   






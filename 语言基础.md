大数据架构底层核心技能⭐️⭐️⭐️⭐️

JAVA：Java高级(虚拟机JVM、多线程&高并发、网络通信IO）

PYTHON

SCALA

SQL以及基本调优，主要是Hive SQL



HiveSQL： https://www.bilibili.com/video/BV1og4y1w7W3/?p=108&share_source=copy_web&vd_source=b0c3cad8671d1f2fa75d01a0a18e195c

# JDK JRE JVM

Java程序是运行在JVM([Java虚拟机](https://so.csdn.net/so/search?q=Java虚拟机&spm=1001.2101.3001.7020))上的，在开发程序之前要配置Java开发环境，而配置环境要做的就是JDK的安装和配置。

三者的大致结构是这样的，简单来说就是JDK包含JRE,JRE又包含JVM的关系。如下图所示：

<img src="assets/image-20230818184432597.png" alt="image-20230818184432597" style="zoom:50%;" />

- JDK：Java Development Kit 是Java的标准开发工具包，普通用户只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。
- JRE：Java runtime environment 是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。
- JVM：Java Virtual Machine 是Java的虚拟机，是JRE的一部分（JVM=JRE的bin）。它是**整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机**。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。



# JAVA的类、接口、泛型

类用于描述具体的对象和实现具体的功能，而接口用于定义规范和行为契约，以便实现类来实现和提供具体的功能。

类提供了更具体和具有实现细节的功能，而接口更加抽象和灵活，可以用于实现多个类之间的共享行为。

泛型的好处是在编译的时候**检查类型安全**，并且所有的强制转换都是自动和隐式的， 以提高代码的重用率。 

- 不加`<String>`指定List的存放数据的类型，会无法加入字符串元素，因为默认只能加`Object`对象，只能接收父类，不能接收子类对象

  ```java
  // 编译时报warning 但可以运行
  public class HelloWorld {
      public static void main(String[] args) {
  		java.util.ArrayList list = new java.util.ArrayList();
  		list.add("Java Programming"); 
  		list.add(123);  
  		list.add(true); 
  		for (Object o : list){
  			System.out.println(o);
  		}
  	}
  }
  // 指定泛型 编译也没问题 但没法再加其他类型的元素
  public class test {
      public static class ShowUncheckedWarning {
          public static void main(String[] args) {  
              java.util.ArrayList<String> list = new java.util.ArrayList<String>();
              list.add("Java Programming");
          }
      }
  }
  ```

- 泛型类：使用引入类型作为类的全局对象

  ```java
  public class Person<T> {
      private T t;
  
      public Person(T t) {
          this.t = t;
      }
  
      public String toString() {
          return "参数的类型是：" + t.getClass().getCanonicalName();
      }
  }
  
  package Generic;
  
  // 继承父类的泛型 子类就可以与父类一起共享类型参数
  public class Teacher<T, S> extends Person<T> {
      protected T t;
      private S s;
  
      public Teacher(T t) {
          super(t);
      }
  
      public void set(T t, S s) {
          this.t = t;
          this.s = s;
      }
  }
  ```

- 泛型接口：其实和泛型类功能上差不多，以下是一个具体的例子

  ```java
  public interface Factory<T> {
      public T create();
  }
  public class Car {
  }
  public class Computer {
  }
  
  public class CarFacotry implements Factory<Car> {
      @Override
      public Car create() {
          System.out.println("装载发动机！");
          System.out.println("装载座椅！");
          System.out.println("装载轮子！");
          return new Car();
      }
  }
  public class ComputerFactory implements Factory<Computer> {
      @Override
      public Computer create() {
          System.out.println("装载主板！");
          System.out.println("装载CPU!");
          System.out.println("装载内存");
          return new Computer();
      }
  }
  ```

  

- 泛型方法：为方法声明一个类型参数，通过`.newInstance()`反射方法，创建返回实例

  ```java
  import java.util.Date;
  
  public class Factory {
      //    定义泛型方法
      public <T> T generator(Class<T> t) throws Exception {
          return t.newInstance();
      }
  
      //  使用泛型方法
      public static void main(String[] args) throws Exception {
          Date date = new Factory().generator(Date.class);
          System.out.println(date);
      }
  }
  ```

  代码简洁而优美，灵活且强大。

  泛型确保了类型的准确性 ，可以使用该方法生成任何继承自Object类的实例。 

  然前提是该类有无参构造方法。

- 
